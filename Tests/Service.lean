/-
  Integration tests for service code generation.
-/
import Protolean

namespace Tests.Service

open Protolean.Service

-- Import the service test proto file
proto_import "service_test.proto"

-- Test that the message types are generated
def sampleRequest : Test.Service.Request := {
  query := "test query"
}

def sampleResponse : Test.Service.Response := {
  result := "test result"
}

-- Test that the service info is generated and accessible
def checkServiceInfo : IO Bool := do
  -- Access the generated service info (testServiceInfo is generated by proto_import)
  let info := Test.Service.testServiceInfo
  if info.name != "TestService" then
    IO.println s!"  FAIL: Expected service name 'TestService', got '{info.name}'"
    return false
  if info.fullName != "test.service.TestService" then
    IO.println s!"  FAIL: Expected fullName 'test.service.TestService', got '{info.fullName}'"
    return false
  if info.methods.length != 2 then
    IO.println s!"  FAIL: Expected 2 methods, got {info.methods.length}"
    return false
  IO.println s!"  PASS: ServiceInfo is correct"
  return true

-- Test the RPC method info
def checkMethodInfo : IO Bool := do
  let info := Test.Service.testServiceInfo
  -- Check Search method (unary)
  match info.findMethod "Search" with
  | some m =>
    if m.inputStream || m.outputStream then
      IO.println "  FAIL: Search should be unary (no streaming)"
      return false
    if m.kind != RpcKind.unary then
      IO.println s!"  FAIL: Search kind should be unary, got {m.kind}"
      return false
  | none =>
    IO.println "  FAIL: Search method not found"
    return false
  -- Check StreamResults method (server streaming)
  match info.findMethod "StreamResults" with
  | some m =>
    if m.inputStream || !m.outputStream then
      IO.println "  FAIL: StreamResults should have outputStream=true only"
      return false
    if m.kind != RpcKind.serverStream then
      IO.println s!"  FAIL: StreamResults kind should be serverStream, got {m.kind}"
      return false
  | none =>
    IO.println "  FAIL: StreamResults method not found"
    return false
  IO.println "  PASS: Method info is correct"
  return true

-- Test that the type class is generated (just verify it exists)
-- We can't easily instantiate it without a mock implementation
def checkTypeClassExists : IO Bool := do
  -- The TestServiceClient type class should exist
  -- This is verified at compile time - if the file compiles, the class exists
  IO.println "  PASS: TestServiceClient type class exists (verified at compile time)"
  return true

-- Mock implementation of the service for testing
instance mockTestService : Test.Service.TestServiceClient IO where
  search req := pure { result := s!"Echo: {req.query}" }
  streamResults req := pure #[{ result := s!"Result 1 for {req.query}" }, { result := s!"Result 2 for {req.query}" }]

-- Test using the mock service
def checkMockService : IO Bool := do
  let response ← Test.Service.TestServiceClient.search sampleRequest
  if response.result != "Echo: test query" then
    IO.println s!"  FAIL: Mock search returned wrong result: {response.result}"
    return false
  let responses ← Test.Service.TestServiceClient.streamResults sampleRequest
  if responses.size != 2 then
    IO.println s!"  FAIL: Mock streamResults returned wrong count: {responses.size}"
    return false
  IO.println "  PASS: Mock service works correctly"
  return true

/-- Run all service tests -/
def runTests : IO Unit := do
  let mut passed := 0
  let mut failed := 0

  IO.println "Testing service info generation..."
  if ← checkServiceInfo then passed := passed + 1 else failed := failed + 1

  IO.println "Testing method info..."
  if ← checkMethodInfo then passed := passed + 1 else failed := failed + 1

  IO.println "Testing type class generation..."
  if ← checkTypeClassExists then passed := passed + 1 else failed := failed + 1

  IO.println "Testing mock service implementation..."
  if ← checkMockService then passed := passed + 1 else failed := failed + 1

  IO.println s!"Service tests: {passed} passed, {failed} failed"

end Tests.Service
